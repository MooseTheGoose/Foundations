# Trigger garbage collector
collect

# Create a new strong reference to an int named strawng
int [strawng] = alloc strong int;

# Create a new weak reference in array of references X.
char [[X]] = alloc strong char[][128]; X[0] = alloc char[256];

# Note that this is illegal.
# Weak references must be children to references (strong or weak).
char [X] = alloc char[128];

# Access element 20 of strawng above
[strawng + 20]

# Declare a pointer to char named Y
char *Y = alloc char[128]

# Free natively allocated space
dealloc Y

# Note that these are illegal
# To keep gc simple, accessing a reference through pointer indirection is illegal.

char *[Z] = alloc char[][128] # Can't have pointer to reference.

struct { int k; int [W]; } *A = alloc char[1024]; 
A->W = alloc int[128]; # Declaration above is fine. This line is the problem.

# Note that these are legal
# Pointers are unmanaged, so having references to pointers is fair game.
# If struct is a reference, then it's alright
 
char [*P] = alloc char *[128];
struct nonanonymous { int k; int [W]; } *its_okay = alloc char[1024]; 
nonanonymous [B] = alloc nonanymous; 
B->W = alloc int[128];





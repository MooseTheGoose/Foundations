# Trigger garbage collector
collect

# Create a new strong reference to an int named strawng
int $[strawng] = alloc int;

# Create a new weak reference to char named X.
char [X] = alloc char[128];

# Declare strong reference to char Y and assign it X.
char $[Y] = X;

# Declare weak reference to weak reference to char Z and assign it X.
char [Z] = X;

# Declare a strong reference to a weak reference to char
char $[[W]];

# Declare a strong reference to a strong reference to char
char $[$[W]];

# Access element 20 of strawng above
[strawng + 20]

# Declare a pointer to char named Y
char *Y = alloc char[128]

# Free natively allocated space
dealloc Y

# Note that these are illegal
# To keep gc simple, accessing a reference through pointer indirection is illegal.

char *[Z] = alloc char[][128] # Can't have pointer to reference.

struct { int k; int [W]; } *A = alloc char[1024]; 
A->W = alloc int[128]; # Declaration above is fine. This line is the problem.

# Note that these are legal
# Pointers are unmanaged, so having references to pointers is fair game.
# If struct is a reference, then it's alright
 
char [*P] = alloc char *[128];
struct nonanonymous { int k; int [W]; } *its_okay = alloc char[1024]; 
nonanonymous [B] = alloc nonanymous; 
B->W = alloc int[128];





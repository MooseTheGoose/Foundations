# Trigger garbage collector
collect

# Create a new weak reference to array of char named X
char [X] = alloc char[128]

# Create a new strong reference to an int named strawng
strong int [strawng] = alloc int;

# Access element 20 of X above
[X + 20]

# Declare a pointer to char named Y
char *Y = alloc char[128]

# Free natively allocated space
dealloc Y

# Note that these are illegal
# To keep gc simple, accessing a reference through pointer indirection is illegal.

char *[Z] = alloc char[][128] # Can't have pointer to reference.

struct { int k; int [W]; } *A = alloc char[1024]; 
A->W = alloc int[128]; # Declaration above is fine. This line is the problem.

# Note that these are legal
# Pointers are unmanaged, so having references to pointers is fair game.
# If struct is a reference, then it's alright
 
char [*P] = alloc char *[128];
struct nonanonymous { int k; int [W]; } *its_okay = alloc char[1024]; 
nonanonymous [B] = alloc nonanymous; 
B->W = alloc int[128];




